Autorem poniższego tekstu jest Mateusz “j00ru” Jurczyk oraz Gynvael Coldwind. W opublikowanym na Niebezpieczniku pod koniec listopada wpisie Exploit 0day na windows – omija UAC autor napisał, że luka ta jest exploitowalna m.in. na Windowsie XP, co spotkało się z protestami niektórych czytelników, którzy zarzucali autorowi wpisu wprowadzanie w błąd. Kwestia ta była o tyle dyskusyjna, że podatna funkcja w systemie Windows XP posiadała dodatkowe zabezpieczenia — nieobecne w wersjach z Visty oraz 7 — w postaci tzw. security cookies (znane również jako stack canaries), które wg. ówczesnego stanu wiedzy zapewniało wystarczającą ochronę przed możliwością wykonania wrogiego kodu, przy użyciu błędu przepełnienia bufora na stosie. W opublikowanym przez nas blisko 40-stronicowym artykule pt. “Exploiting the otherwise non-exploitable – Windows Kernel-mode GS Cookies subverted” udowadniamy, że ciasteczka w domyślnych sterownikach systemu Windows są bardzo słabe, a co za tym idzie, omawiany błąd jest jak najbardziej exploitowalny na Windows XP. Udane podniesienie uprawnień użytkownika systemu Windows XP SP3 przy użyciu wspomnianej luki bezpieczeństwa zostało przedstawione na poniższym nagraniu. Słabe źródła entropii Poziom bezpieczeństwa zapewnianego przez wspomniane wcześniej ciasteczka w dużej mierze zależy od doboru odpowiednio dobrych źródeł entropii podczas jego inicjalizacji – im bardziej losowe i nieprzewidywalne źródło, tym bezpieczniejsze ciastko oraz odwrotnie – im bardziej przewidywalne źródła entropii, tym szacowanie prawidłowej wartości ciastka staje się łatwiejsze. Security cookies? Jak zapewne większość czytelników Niebezpiecznika wie, ciasteczko bezpieczeństwa umieszczane na stosie to pewna losowa (tj. trudna do przewidzenia przez atakującego) wartość oddzielająca zmienne lokalne funkcji od adresu powrotu. Bezpośrednio przed opuszczeniem funkcji następuje weryfikacja poprawności wartości ciasteczka. Jeśli owa wartość okazuje się być zmodyfikowana w trakcie wykonywania chronionej funkcji, dalsze działanie kodu (programu, systemu) zostaje awaryjnie wstrzymane. W przypadku trybu jądra, rezultatem jest dobrze znany Blue Screen of Death. W przypadku domyślnego sterownika win32k.sys (winowajcy we wspomnianym “błędzie z UAC”) globalna wartość cookie jest generowana przy wykorzystaniu dwóch lub trzech źródeł entropii, w zależności od wersji Windowsa: adresu wirtualnego (VA) zmiennej globalnej win32k!__security_cookie (w której przechowywana jest wzorcowa wartość ciasteczka), aktualnego adresu ramki stosu w momencie wejścia do funkcji (tylko w Vista/7/2008), aktualnego czasu, mierzonego w tickach (w tym przypadku 1 tick = ~1/64 sekundy) od startu systemu. W praktyce, ustalenie adresu zmiennej __security_cookie dla konkretnego modułu jest trywialne i sprowadza się do znalezienia relatywnego adresu __security_cookie, korzystając z pliku win32k.sys na atakowanej maszynie, odpytania systemu pod jakim adresem win32k.sys znajduje się w pamięci (można skorzystać z funkcji NtQuerySystemInformation) oraz połączeniu tych informacji – przekształceniu adresu relatywnego zmiennej (RVA) na adres bezwzględny (VA). Analogicznie sprawa przedstawia się w przypadku ramki stosu – stały offset od początku stosu można wyliczyć np. posługując się dead-listingiem disassemblera lub WinDbg na innej maszynie z takim samym systemem (co do zestawu patchy). Natomiast adres początku stosu trybu jądra dla danego wątku dostarcza nam system, a konkretniej natywna funkcja API NtQuerySystemInformation z parametrem SystemExtendedProcessInformation. Pozostaje więc problem ilości ticków od momentu startu systemu i tutaj sprawa się komplikuje – system nie udziela precyzyjnych informacji dotyczących czasu załadowania drivera. Istnieje jednak kilka sposobów pozwalających oszacować tę wartość z bardzo dużą dokładnością. Główna koncepcja opiera się na odpytywaniu jądra Windows o dokładny czas szczególnych zdarzeń – pośrednio lub bezpośrednio związanych z ładowaniem sterownika – takich jak czas utworzenia procesu powodującego załadowanie drivera, bądź czas utworzenia linku symbolicznego do danego urządzenia. Po złożeniu trzech odrębnych informacji w spójną całość, otrzymujemy oczekiwaną (poprawną) wartość ciastka, lub – w gorszym przypadku – jej przybliżenie. Dzięki temu, możliwe staje się ominięcie (bądź też oszukanie) zabezpieczenia w trakcie wykorzystywania błędu przepełnienia stosu i skierowanie ścieżki wykonywania kodu pod specjalnie spreparowany adres powrotu. (Po szczegóły wraz z wynikami testów empirycznych zapraszamy do artykułu.) Dalszy los GS Cookies We wspomnianej publikacji znajduje się kilka propozycji, dotyczących możliwości przewidywania ciasteczka w zależności od czynników niezależnych od atakującego (takich jak rodzaj sterownika, w którym znajduje się błąd). W niektórych przypadkach całkowita entropia GS cookies została zredukowana do jednego bitu (skuteczność ataku oscyluje na poziomie 50%), w innych – do kilku (maksymalnie 6) bitów. Należy jednak zauważyć, że dokument w żaden sposób nie porusza tematyki zabezpieczenia stosu w samym obrazie jądra Windows (a więc ntoskrnl.exe i pochodne), gdzie ciasteczko generowane jest w inny sposób. Kontakt z Microsoftem O wyniku naszych badań poinformowaliśmy Microsoft (6 grudnia 2010), który potwierdził otrzymanie informacji i dwa dni później przesłał odpowiedź z której wynika, że zespół systemu Windows jest świadomy problemu i rozważa zmianę metody generowania ciasteczka w przyszłych wersjach systemu. Firma Microsoft nie zwróciła się z prośbą o opóźnienie terminu publikacji artykułu. ,Mr. Niebezpieczny