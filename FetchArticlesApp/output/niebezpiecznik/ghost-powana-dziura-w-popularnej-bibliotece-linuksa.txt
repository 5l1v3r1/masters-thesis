Dziura znajdująca się w kluczowej bibliotece Linuksa, glibc (do wersji 2.18), pozwala atakującym na całkowite przejęcie kontroli nad systemem. I chociaż luka wcale nie jest taka łatwa do wykorzystania, lepiej szybko zaaplikujcie patche! GHOST straszy Ostatnie miesiące obfitują w “ciężkie” i szeroko exploitowalne podatności (będące przy okazji PR-owymi perełkami z własnymi logotypami i dedykowanymi stronami internetowymi). Był Heartbleed i Shellshock (bash bug), a teraz pora na GHOST, podatność typu buffer overflow, którą zidentyfikowano w funkcji __nss_hostname_digits_dots() biblioteki glibc, czyli GNU C Library. Szczegóły znajdziecie w obszernym poście na liście OSS Security. Co ciekawe, wszystko wskazuje na to, że błąd został ujawniony światu przedwcześnie, poprzez błąd osoby (z agencji PR?), która wysłała opis problemu na francuską listę mailingową. Ta wpadka (i “marketingowa” otoczka wokół podatności) nie uszła branżowym oczom — polecamy prześmiewczy post lcamtufa na ten temat :-) Na czym polega atak? Za pomocą dziury w glibc atakujący może przejąć całkowitą kontrolę nad waszym serwerem. Atak może przeprowadzić zdalnie, czyli np. przez internet, jak i lokalnie (jeśli posiada konto na atakowanym systemie). Exploity już są dostępne. Warto podkreślić, że na atak podatnych jest wiele aplikacji, które korzystają z protokołu DNS poprzez funkcje z rodziny gethostbyname*(). I choć funkcja ta nie jest polecana (“deprecated”) to wciąż mogą z niej korzystać niektóre z usług. Przykładowo, podatne na atak mogą być: Serwery pocztowe, które resolvują domeny/adresy IP (funkcje DNS blacklistingu, sprawdzenia SPF, itp.). Badaczom z Qualysa udało się przy pomocy GHOST i odpowiednio spreparowanego e-maila przesłanego na serwer Exima (wymaga jest jednak jego “sprzyjająca” konfiguracja), przejąć kontrolę nad serwerem omijając ASLR, PIE i NX zarówno na architekturze 32 jak i 64 bitowej. Formularze w serwisach internetowych, które powodują zapytania DNS (np. IP komentującego) Serwery SSH, które wykonują zapytania DNS w kwestii uwierzytelnienia na podstawie regułek allow/deny Podatności nadano już identyfikator CVE-2015-0235. Jak sprawdzić, czy jestem podatny? Pierwsza podatna na atak biblioteka glibc pochodzi z 2000 roku (glibc-2.2) i co ciekawe, podatność została “przypadkowo” usunięta 21 maja 2013 roku w glibc-2.18, ale ponieważ nie było to wydanie związane z bezpieczeństwem, większość systemów według Qualysa dalej posiada starsze, dziurawe wersje glibc. Dlatego lepiej sprawdźcie jaką wersję posiada wasz system lub przetestujcie go na ewentualność tej dziury poniższym skryptem: wget https://gist.githubusercontent.com/koelling/ef9b2b9d0be6d6dbab63/raw/ de1730049198c64eaf8f8ab015a3c8b23b63fd34/gistfile1.c gcc gistfile1.c -o CVE-2015-0235 ./CVE-2015-0235 Qualys opublikował kod programu, którego uruchomienie daje odpowiedni werdykt: #include <netdb.h> #include <stdio.h> #include <stdlib.h> #include <string.h> #include <errno.h> #define CANARY "in_the_coal_mine" struct { char buffer[1024]; char canary[sizeof(CANARY)]; } temp = { "buffer", CANARY }; int main(void) { struct hostent resbuf; struct hostent *result; int herrno; int retval; /*** strlen (name) = size_needed - sizeof (*host_addr) - sizeof (*h_addr_ptrs) - 1; ***/ size_t len = sizeof(temp.buffer) - 16*sizeof(unsigned char) - 2*sizeof(char *) - 1; char name[sizeof(temp.buffer)]; memset(name, '0', len); name[len] = '\0'; retval = gethostbyname_r(name, &resbuf, temp.buffer, sizeof(temp.buffer), &result, &herrno); if (strcmp(temp.canary, CANARY) != 0) { puts("vulnerable"); exit(EXIT_SUCCESS); } if (retval == ERANGE) { puts("not vulnerable"); exit(EXIT_SUCCESS); } puts("should not happen"); exit(EXIT_FAILURE); } Sprawdzenia można dokonać w ten sposób: wget https://gist.githubusercontent.com/koelling/ef9b2b9d0be6d6dbab63/raw/ de1730049198c64eaf8f8ab015a3c8b23b63fd34/gistfile1.c gcc gistfile1.c -o CVE-2015-0235 ./CVE-2015-0235 Jak usunąć podatność? Gdzie są patche? Ponieważ dostępne są już patche dla poszczególnych dystrybucji (Debian, RedHat), należy jak najszybciej je wgrać (czyli zaktualizować glibc do najnowszej wersji). Nie zapomnijcie po aktualizacji zrestartować wszystkich usług, które wykorzystują glibc: $ lsof | grep libc | awk '{print $1}' | sort | uniq ,Piotr Konieczny